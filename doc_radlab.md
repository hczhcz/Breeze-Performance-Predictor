使用说明
===

左上“Input 1”和“Input 2”分别打开**输入文件**（在`./data`有样例）。可以手动指定**输出文件**“Output 1”和“Output 2”。

右上第一个拖动条控制计算过程中，*文件1*的相似度关系表从*文件2*的相似度关系表中混合的比例。向左表示**混合**更多，向右表示**保持**更多。

右上第二个拖动条类似于第一个，即*文件2*的相似度关系表从*文件1*的相似度关系表中混合的比例。

右上第三个拖动条是同一文件各*X坐标*（服务）之间和各*Y坐标*（用户）之间的相似度关系表的依赖比例，即原paper中的*Lambda值*。向左表示计算过程更多依赖**用户相似度**，向右表示更多依赖**服务相似度**。

选项中，“Auto Lambda”表示不使用固定的*Lambda值*、而使用一个经验公式完成计算；“Sqrt Filtering”表示在计算前对输入开根号、在计算后对结果平方；“Intersection”表示在计算相似度时，使用对于*Y*（用户）而言*X*（服务）的特征计算*X*（服务）相似度、使用对于*X*而言*Y*的特征计算*Y*相似度，若不勾选则相反。

设置完毕后，点击**“Go”**即开始计算，进度条表示计算进度。

两张图表是**深度图**，横坐标为*X*（服务），纵坐标为*Y*（用户），分别表示第一、第二组结果中各个值的大小。绿色表示已知的值，蓝色表示预测的值，颜色越深表示数值越大。将鼠标放到图上指向数据点，可查看各个点的数据。

文件格式
===

文件第一行两个整数，分别代表*X坐标*和*Y坐标*的大小，之后共有*Y*行，每行*X*个数据。

每个数据点即为已知数据的平均值，若值**为零**则表示该点未知。

源码结构
===

math
---

封装了数学函数、操作符等。

`MathFunc`是函数，`MathOper`是二元操作符。

包中提供了三个辅助工具：

* `ConditionalOper`判断，如果第一个操作数大于0则计算。
* `CurryingFunc`对二元操作符的第二个操作数进行*科里化*，例如`x+y`变为`x+1`。
* `AppliedOper`将一元函数和二元操作符组合使用。

matrix_math
---

“矩阵”之名是为了方便称呼，**实质是二位数组的封装**。

`FileMatrix`提供文件IO，`X2YMatrix`和`Y2XMatrix`分别将一个`x*y`的矩阵取一行或一列，变成`1*y`和`x*1`的。

包中提供了一些迭代工具，包括逐个元素应用函数、操作符，逐行或逐列的*map*和*reduce*操作，见`MatrixScanner`。

performance_calc
---

建立在`math`和`matrix_math`上，主要的**计算的逻辑**。将数据类型定为`Float`，之前的包是泛型的。

计算的逻辑见`CalcContainer`。

`MathToolSet`提供了一些数学函数、操作符的实现。

`Progress`提供了一个进度条底层抽象供UI使用。

non_gui
---

命令行前端，用于调试。

gui
---

**图形化前端，基于SWT。**

`Builder`相关类封装了**建立用户界面**的代码，可向`BuilderAll`构造器传入一个使用`FormLayout`的`Composite`类用来装载界面内容。

`Window`封装了一个窗口，直接将窗口作为界面内容的容器，`BuilderAll`画出完整界面。若需要将界面内容嵌入其它地方，做法类似，可以参考这里的实现。

四个模块：

* `File`在左上角，打开、保存文件。
* `Lambda`在右上角，各种设置。
* `Exec`在中间，包括进度条和“Go”按钮。
* `Canvas`即图表。

`Message`是自动生成的文件，`messages.properties`中存放GUI使用的字符串。

本文档
===

最后更新2014.08.20，[hcz](mailto:h.cz@qq.com)。
